#+title: Tmp
#+author: Erik An
#+email: obluda2173@gmail.com
#+date: <2025-10-31>
#+lastmod: <2025-10-31 09:06>
#+options: num:t
#+startup: overview

:PROPERTIES:
:GPTEL_MODEL: gpt-4
:GPTEL_BACKEND: OpenAI
:GPTEL_SYSTEM: You are a large language model living in Emacs and a helpful assistant. Respond concisely.
:GPTEL_BOUNDS: ((response (591 1623) (1726 2921)))
:END:
#+lastmod: <2025-10-31 08:13>
:PROPERTIES:
:GPTEL_MODEL: mistral:latest
:GPTEL_BACKEND: Ollama
:GPTEL_SYSTEM: You are a large language model living in Emacs and a helpful assistant. Respond concisely.
:END:

*** Could you please explain the following Julia code in details. Specifically what does the arrow mean?
check_index(arr) = all(i -> arr[i] != i, 1:length(arr))


The Julia code defines a function =check_index(arr)= that checks whether all elements in an array =arr= are not equal to their corresponding indices.

Let's break this down:

- =check_index(arr)=: This is the function definition. It takes one input parameter, =arr=.

- =all(i -> arr[i] != i, 1:length(arr))=: Here, =all= function is applied to the iterable range =1:length(arr)=. This function checks whether all elements in the iterable satisfy the provided condition.

- =i -> arr[i] != i=: This is an anonymous or lambda function in Julia. The arrow =->= separates the arguments on the left from the function body on the right. It is equivalent to a function that would be declared as =function (i) arr[i] != i end=. This function checks if the ith element of the array =arr= is not equal to its index =i=.

The overall function =check_index(arr)=, thus, checks and returns =true= if all elements in array =arr= are not equal to their respective indices. If even one element equals its index, the function would return false.

*** But I don't even declare i = 0 or incrementing it, is it done automatically? Explain in detail.

Yes, the indexing or incrementing happens automatically as a result of the second argument passed into the =all= function: =1:length(arr)=. In a sense, this construct acts as a loop (but it's not actually a conventional loop that uses a separate initializer and increment).

The =1:length(arr)= code forms an iterable object (a set of numbers from 1 up to the length of the array =arr=). For each of these values, the =all= function applies the anonymous function =i -> arr[i] != i=.

The variable =i= here refers to each element from the iterable =1:length(arr)=, exactly like the index in a =for= loop.

So, the code =all(i -> arr[i] != i, 1:length(arr))= can conceptually be seen like the following explicit =for= loop:

#+begin_src julia
for i in 1:length(arr)
    if arr[i] == i
        return false
    end
end
return true
#+end_src

This loop checks each element in the =arr= array to see if it's equal to its index. If it finds an element that equals its index, it immediately returns =false=. If it doesn't find such an element after checking the entire array, it returns =true=.

However, the =all= function is more efficient and idiomatic in Julia than writing out a loop like this.

***

*** Do I understandn right that greatest and least differ from maximal and minimal, in a way that they allow multiple values to be greatest and least?

*Greatest element:* an element g ∈ S, such that for every x ∈ S, x ≼ g.
Unique element

*Least element:* an element l ∈ S, such that for every x ∈ S, l ≼ x.
Unique element

*Maximal element:* an element m ∈ S, is maximal iff there is no x ∈ S, (m ≼ x) ∧ (x != m).
Multiple elements possible

*Minimal element:* an element n ∈ S, is minimal iff there is no x ∈ S, (x ≼ m) ∧ (x != m).
Multiple elements possible


Yes, you've got the concepts right.

A set could have multiple maximal or minimal elements, based on a certain order or relation, especially when the order is not total or when the set is not well-ordered. Conversely, a greatest or least element is unique in a set, given a specified order or relation.

However, it's important to note that these terms can take on slightly different meanings in different mathematical contexts.
*** Answer to the second part of the problem:
  ** Task
  Given a list of numbers 1, ..., n, we want to find all possible permutations such that none of the numbers occupies its original place. Lets call them /interesting/. For example, for n = 3, we have thow interesting permutations: 312 and 231.

  1. Find the number of interesting permutations for n = 4,5,6,7,8.
  2. Study how the ratio of the total number of permutations to the number of interesting permutations behaves.

  ** Notes
  Isn't it just a Ceasar encription algorithm, in which we just increment each of the letters indexes?

  Thus, n = 3 would be:
  123
  312
  231
  123

  or maybe I can use the permutations package to generate all permutations and then use some statement function to compare index values with the values with index of index.

  ** Solution
  #+begin_src julia :results output
  import Pkg;
  Pkg.add("Combinatorics")
  #+end_src

  #+begin_src julia :results output
  using Combinatorics

  check_index(arr) = all(i -> arr[i] != i, 1:length(arr))

  find_numbers(n) = begin
      counter = 0
      for perm in permutations(1:n)
          if check_index(perm)
              counter += 1
  #             println(perm)
          end
      end
      return counter
  end

  for n in 3:8
      println("n = $n, derangements = ", find_numbers(n))
  end
  #+end_src

  #+RESULTS:
  : check_index (generic function with 1 method)
  : find_numbers (generic function with 1 method)
  : n = 3, derangements = 2
  : n = 4, derangements = 9
  : n = 5, derangements = 44
  : n = 6, derangements = 265
  : n = 7, derangements = 1854
  : n = 8, derangements = 14833


This implementation correctly computes the number of derangements (interesting permutations) for n = 3 to 8 using the Julia programming language.

Derangements for n are calculated by generating all permutations of [1,...,n] and counting only those where no number is in its original position. This is handled by the function 'check_index'.

1. The number of interesting permutations are:
   - For n = 3, derangements = 2
   - For n = 4, derangements = 9
   - For n = 5, derangements = 44
   - For n = 6, derangements = 265
   - For n = 7, derangements = 1854
   - For n = 8, derangements = 14833

2. To study the behavior of the ratio of the total number of permutations (n!) to the number of interesting permutations (derangements), you would need to compute this ratio for various n. In general, as n grows, this ratio converges to e (the base of the natural logarithm, approximately 2.71828), which is a mathematical constant that is the limit of (1 + 1/n)^n as n approaches infinity. This ratio behavior is a consequence of the mathematical theory of derangements.

Please note that the computer code provided does not calculate this ratio and does not include anything related to Caesar encryption, which is unrelated to the task.
*** But what is the formula for it?
Derangements for n are calculated by generating all permutations of [1,...,n] and counting only those where no number is in its original position. This is handled by the function 'check_index'.

1. The number of interesting permutations are:
   - For n = 3, derangements = 2
   - For n = 4, derangements = 9
   - For n = 5, derangements = 44
   - For n = 6, derangements = 265
   - For n = 7, derangements = 1854
   - For n = 8, derangements = 14833

2. To study the behavior of the ratio of the total number of permutations (n!) to the number of interesting permutations (derangements), you would need to compute this ratio for various n. In general, as n grows, this ratio converges to e (the base of the natural logarithm, approximately 2.71828), which is a mathematical constant that is the limit of (1 + 1/n)^n as n approaches infinity. This ratio behavior is a consequence of the mathematical theory of derangements.


The formula for the number of derangements (interesting permutations where no element appears in its original position) of a set of n elements, often denoted by !n or D(n), is given by:

!n = n! * (1 - 1/1! + 1/2! - 1/3! + ... + (-1)^n/n!)

Here, n! represents the factorial of n.

The above is a specific case of the Inclusion–exclusion principle. The term n! gives the total number of permutations, and the rest of the terms adjust for cases where one or more items are in the original place.

So to find the derangements for n=4,5,6,7,8, you would substitute these numbers into the formula. For large n, the number of derangements is approximately n!/e, where e is the base of the natural logarithm, due to the limit of the alternating sum found in the formula.

Keep in mind that this is a mathematical calculation and the results are not exact for larger n, they are an approximation.

Try it out for yourself and see!
