#+title: Problem Set 8
#+author: Erik An
#+email: obluda2173@gmail.com
#+date: <2025-10-27>
#+lastmod: <2025-10-29 12:03>
#+options: num:t
#+startup: overview

* Problem 1 [IN PROGRESS]
** Task
Is this a function from ℝ to ℝ?

1. f = {(x^2, x); x ∈ ℝ}.
2. f = {(x^3, x); x ∈ ℝ}.

** Notes
*Topic.* Functions

- What is the function?
- What does it mean "a function from ℝ to ℝ"?
  Meaninng that the function input and function output are both real numbers.

  f : ℝ -> ℝ
  Both, the doman and codomain are ℝ numbers.

** Solution
1. f = {(x^2, x); x ∈ ℝ}.

* Problem 2
** Task
** Notes
** Solution
* Problem 3
** Task
** Notes
** Solution
* Problem 4
** Task
** Notes
** Solution
* Problem 5
** Task
** Notes
** Solution
* Problem 6 [IN PROGRESS]
** Task
Given a list of numbers 1, ..., n, we want to find all possible permutations such that none of the numbers occupies its original place. Lets call them /interesting/. For example, for n = 3, we have thow interesting permutations: 312 and 231.

1. Find the number of interesting permutations for n = 4,5,6,7,8.
2. Study how the ratio of the total number of permutations to the number of interesting permutations behaves.

** Notes
Isn't it just a Ceasar encription algorithm, in which we just increment each of the letters indexes?

Thus, n = 3 would be:
123
312
231
123

** Solution
#+begin_src julia :results output

#+end_src

#+RESULTS:
: hello world?

* Problem 7 [DONE]
** Task
How many numbers between 1111111 and 9999999 are divisible by 3 or 5 but not 11?

** Notes
Its way to easy. Maybe I can work on optimisation. Like skipping if number ends by 2,4,6,8.

** Solution
- Solution 1
  #+begin_src julia :results output
  function count_numbers()
      function statement(n::Int)
          if (n % 3 == 0) && (n % 5 == 0) && (n % 11 != 0)
              return true
          end
          return false
      end

      counter = 0
      i = 1111111
      while i <= 9999999
          if statement(i)
              counter += 1
          end
          i += 1
      end

      println("number of found numbers:", counter)
  end

  count_numbers()
  #+end_src

  #+RESULTS:
  : count_numbers (generic function with 1 method)
  : number of found numbers:538720

- Solution 2
  #+begin_src julia :results output
  println("number of found numbers: ", count(n -> (n % 3 == 0) && (n % 5 == 0) && (n % 11 != 0), 1111111:9999999))
  #+end_src

  #+RESULTS:
  : Number of found numbers: 538720

* Problem 8 [DONE]
** Task
Let us call a natural number charismatic if the sum of its digits is a perfect square. Find the sum of all charismatic numbers between 111111 and 999999.

** Notes
** Solution
- Solution 1
  #+begin_src julia :results output
  find_sum() = begin
      statement(n) = begin
          sum_of_digits = sum(map(x -> parse(Int, x), collect(string(n))))
          sqrt_sum = sqrt(sum_of_digits)
          return sqrt_sum == floor(sqrt_sum)
      end

      i = 111111
      sum_char = 0
      while i <= 999999
          if statement(i)
              sum_char += i
          end
          i += 1
      end

      println("sum of all charismatic numbers: ", sum_char)
  end

  find_sum()
  #+end_src

  #+RESULTS:
  : find_sum (generic function with 1 method)
  : sum of all charismatic numbers: 47061011005

- Solution 2
  #+begin_src julia :results output
  is_charismatic(n) = begin
      s = sum(parse.(Int, collect(string(n))))
      sqrt(s) == floor(sqrt(s))
  end

  find_sum() = begin
      total = sum(i for i in 111111:999999 if is_charismatic(i))
      println("sum of all charismatic numbers: ", total)
  end

  find_sum()
  #+end_src

  #+RESULTS:
  : is_charismatic (generic function with 1 method)
  : find_sum (generic function with 1 method)
  : sum of all charismatic numbers: 47061011005
