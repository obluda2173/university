#+title: Problem Set 8
#+author: Erik An
#+email: obluda2173@gmail.com
#+date: <2025-10-27>
#+lastmod: <2025-10-29 21:06>
#+options: num:t
#+startup: overview

* Problem 1 [IN PROGRESS]
** Task
Is this a function from ℝ to ℝ?

1. f = {(x^2, x); x ∈ ℝ}.
2. f = {(x^3, x); x ∈ ℝ}.

** Notes
*Topic.* Functions

- What is the function?
- What does it mean "a function from ℝ to ℝ"?
  Meaninng that the function input and function output are both real numbers.

  f : ℝ -> ℝ
  Both, the doman and codomain are ℝ numbers.

** Solution
1. f = {(x^2, x); x ∈ ℝ}.

   Yes, since

* Problem 2
** Task
A function f : ℤ x ℤ -> ℤ is defined as f(m,n) = 3n - 4m. Verify whether this function is injective and whether it is surjective.

** Notes
- Injective is when each element of codomain has at most one relation with element of domain

- Surjective is when each element of codomain has relation(s) with element(s) of domain

- Function takes Cartesian product of two integer sets and returns an integer

** Solution
#+begin_quote Surjection proof
*Proposition.* f : ℤ x ℤ -> ℤ where f(m,n) = 3n - 4m is surjective.

*Proof.*

2k = 3n - 4n    # prove that any integer can be written as 3n - 4k.

1 = 3 * -1 - 4 * -1     = -3 + 4
2 = 3 * -2 - 4 * -2     = -6 + 8
3 = 3 * -3 - 4 * -3     = -9 + 12
...

General formula:

Let n = m, n ∈ ℤ

n = -n * (3 - 4)
n = -n * -1
n = n

This means that any integer can be written as 3n - 4m, where n,m ∈ ℤ.

Thus, f is surjective.
#+end_quote

#+begin_quote
*Proposition.* f : ℤ x ℤ -> ℤ where f(m,n) = 3n - 4m is injective.

*Proof.* Assume b ∈ ℤ.

Let b = 1.

Since,
1 = 3 * -1 - 4 * -1
and
1 = 3 * 3 - 4 * 2.

Since 1 can be written in multiple ways in the form of 3n - 4m, function f is not injective.
#+end_quote

* Problem 3
** Task
** Notes
** Solution
* Problem 4
** Task
** Notes
** Solution
* Problem 5
** Task
** Notes
** Solution
* Problem 6 [DONE]
** Task
Given a list of numbers 1, ..., n, we want to find all possible permutations such that none of the numbers occupies its original place. Lets call them /interesting/. For example, for n = 3, we have thow interesting permutations: 312 and 231.

1. Find the number of interesting permutations for n = 4,5,6,7,8.
2. Study how the ratio of the total number of permutations to the number of interesting permutations behaves.

** Notes
Isn't it just a Ceasar encription algorithm, in which we just increment each of the letters indexes?

Thus, n = 3 would be:
123
312
231
123

or maybe I can use the permutations package to generate all permutations and then use some statement function to compare index values with the values with index of index.

** Solution
#+begin_src julia :results output
import Pkg;
Pkg.add("Combinatorics")
#+end_src

#+begin_src julia :results output
using Combinatorics

check_index(arr) = all(i -> arr[i] != i, 1:length(arr))

find_numbers(n) = begin
    counter = 0
    for perm in permutations(1:n)
        if check_index(perm)
            counter += 1
#             println(perm)
        end
    end
    return counter
end

for n in 3:8
    println("n = $n, derangements = ", find_numbers(n))
end
#+end_src

#+RESULTS:
: check_index (generic function with 1 method)
: find_numbers (generic function with 1 method)
: n = 3, derangements = 2
: n = 4, derangements = 9
: n = 5, derangements = 44
: n = 6, derangements = 265
: n = 7, derangements = 1854
: n = 8, derangements = 14833

* Problem 7 [DONE]
** Task
How many numbers between 1111111 and 9999999 are divisible by 3 or 5 but not 11?

** Notes
Its way to easy. Maybe I can work on optimisation. Like skipping if number ends by 2,4,6,8.

** Solution
- Solution 1
  #+begin_src julia :results output
  function count_numbers()
      function statement(n::Int)
          if (n % 3 == 0) && (n % 5 == 0) && (n % 11 != 0)
              return true
          end
          return false
      end

      counter = 0
      i = 1111111
      while i <= 9999999
          if statement(i)
              counter += 1
          end
          i += 1
      end

      println("number of found numbers: ", counter)
  end

  count_numbers()
  #+end_src

  #+RESULTS:
  : count_numbers (generic function with 1 method)
  : number of found numbers:538720

- Solution 2
  #+begin_src julia :results output
  println("number of found numbers: ", count(n -> (n % 3 == 0) && (n % 5 == 0) && (n % 11 != 0), 1111111:9999999))
  #+end_src

  #+RESULTS:
  : Number of found numbers: 538720

* Problem 8 [DONE]
** Task
Let us call a natural number charismatic if the sum of its digits is a perfect square. Find the sum of all charismatic numbers between 111111 and 999999.

** Notes
** Solution
- Solution 1
  #+begin_src julia :results output
  find_sum() = begin
      statement(n) = begin
          sum_of_digits = sum(map(x -> parse(Int, x), collect(string(n))))
          sqrt_sum = sqrt(sum_of_digits)
          return sqrt_sum == floor(sqrt_sum)
      end

      i = 111111
      sum_char = 0
      while i <= 999999
          if statement(i)
              sum_char += i
          end
          i += 1
      end

      println("sum of all charismatic numbers: ", sum_char)
  end

  find_sum()
  #+end_src

  #+RESULTS:
  : find_sum (generic function with 1 method)
  : sum of all charismatic numbers: 47061011005

- Solution 2
  #+begin_src julia :results output
  is_charismatic(n) = begin
      s = sum(parse.(Int, collect(string(n))))
      sqrt(s) == floor(sqrt(s))
  end

  find_sum() = begin
      total = sum(i for i in 111111:999999 if is_charismatic(i))
      println("sum of all charismatic numbers: ", total)
  end

  find_sum()
  #+end_src

  #+RESULTS:
  : is_charismatic (generic function with 1 method)
  : find_sum (generic function with 1 method)
  : sum of all charismatic numbers: 47061011005
