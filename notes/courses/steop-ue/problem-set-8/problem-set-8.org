#+title: Problem Set 8
#+author: Erik An
#+email: obluda2173@gmail.com
#+date: <2025-10-27>
#+lastmod: <2025-10-31 09:07>
#+options: num:t
#+startup: overview

* Problem 1 [DONE] [CHECKED]
** Task
Is this a function from ℝ to ℝ?

1. f = {(x^2, x); x ∈ ℝ}.
2. f = {(x^3, x); x ∈ ℝ}.

** Notes
*Topic.* Functions

- What is the function?
- What does it mean "a function from ℝ to ℝ"?
  Meaninng that the function input and function output are both real numbers.

  f : ℝ -> ℝ
  Both, the doman and codomain are ℝ numbers.

** Solution
1. f = {(x^2, x); x ∈ ℝ}.

   No, since x^2 = 4 could lead to:
   x =  2 = (4,  2) ∈ ℝ
   x = -2 = (4, -2) ∈ ℝ

   Thus, the same input of 4 gives the two different outputs of 2 and -2.

2. f = {(x^3, x); x ∈ ℝ}.

   Yes, since x^3 is strictly increasing function. With each x giving unique x^3, and each x^3 corresponding to unique x.

* Problem 2 [DONE] [CHECKED]
** Task
A function f : ℤ x ℤ -> ℤ is defined as f(m,n) = 3n - 4m. Verify whether this function is injective and whether it is surjective.

** Notes
- Injective is when each element of codomain has at most one relation with element of domain

- Surjective is when each element of codomain has relation(s) with element(s) of domain

- Function takes Cartesian product of two integer sets and returns an integer

** Solution
#+begin_quote Surjection proof
*Proposition.* f : ℤ x ℤ -> ℤ where f(m,n) = 3n - 4m is surjective.

*Proof.*

2k = 3n - 4n    # prove that any integer can be written as 3n - 4k.

1 = 3 * -1 - 4 * -1     = -3 + 4
2 = 3 * -2 - 4 * -2     = -6 + 8
3 = 3 * -3 - 4 * -3     = -9 + 12
...

General formula:

Let n = m, n ∈ ℤ

n = -n * (3 - 4)
n = -n * -1
n = n

This means that any integer can be written as 3n - 4m, where n,m ∈ ℤ.

Thus, f is surjective.
#+end_quote

#+begin_quote
*Proposition.* f : ℤ x ℤ -> ℤ where f(m,n) = 3n - 4m is injective.

*Proof.* Assume b ∈ ℤ.

Let b = 1.

Since,
1 = 3 * -1 - 4 * -1
and
1 = 3 * 3 - 4 * 2.

Since 1 can be written in multiple ways in the form of 3n - 4m, function f is not injective.
#+end_quote

* Problem 3 [DONE] [CHECKED]
** Task
Prove that the function f : ℝ \ {2} -> ℝ \ {5} defined by f(x) = (5x+1)/(x-2) is bijective.

** Notes
ℝ \ {2} all real numbers except 2
ℝ \ {5} all real numbers except 5

Injective, all codomain elements have at most one relation with domain element.
Surjective, all codomain elements have at least one relation with domain elements.

Basically, I am asked to prove that every ℝ (except of 25/3) can be written in the form (5x+1)/(x-2) with x being any ℝ except of 5.

Let x ∈ ℝ,

(5x+1)/(x-2)

x = -2 : f(x) = 9/4
x = -1 : f(x) = 4/3
x = 0 : f(x) = -1/2
x = 1 : f(x) = -6
x = 2 : f(x) = inf
x = 3 : f(x) = 16
x = 4 : f(x) = 21/2
x = 5 : f(x) = 26/3
x = 6 : f(x) = 31/4

The graph is reciprocal, with horizontal asymptote of 5 and vertical of 2.

If we will fill the graph with infinite amount of horizontal lines, (horizontal bijection test), we will see that each horizontal line intersect the graph only at one spot. Meaning graphs is bijective.

** Solution
for every possible output, there exists an input that produces it.
#+begin_quote Surjective proof
*Proposition.* f : ℝ \ {2} -> ℝ \ {5}, f(x) = (5x+1)/(x-2) is surjective.

*Proof.* Let y ∈ ℝ \ {5} be arbitrary,

y = (5x + 1)/(x - 2)
y(x - 2) = 5x + 1
yx - 5x = 2y + 1
x = (2y + 1)/(y - 5)    (y != 5)

x is ℝ, and x != 2, since this would give contradiction 1 = -10. Thus, x ∈ ℝ \ {2} and f(x) = y. Because y was arbitrary in ℝ \ {5}, f is surjective.
#+end_quote

if two outputs are equal, then their inputs must be equal.
#+begin_quote Injective proof
*Proposition.* f : ℝ \ {2} -> ℝ \ {5}, f(x) = (5x+1)/(x-2) is injective.

*Proof.* Assume f(x), f(y) ∈ ℝ, and f(x) = f(y).

f(x) = (5x+1)/(x-2)
f(y) = (5y+1)/(y-2)

Thus,
     (5x+1)/(x-2) = (5y+1)/(y-2)
      (5x+1)(y-2) = (5y+1)(x-2)
5xy - 10x + y - 2 = 5yx - 10y + x - 2
    5xy - 10x + y = 5yx - 10y + x
              11x = 11y

Therefore, x = y.

Since f(x) = f(y) implies x = y, f is injective.
#+end_quote

#+begin_quote Bijection proof
*Proposition.* f : ℝ \ {2} -> ℝ \ {5}, f(x) = (5x+1)/(x-2) is bijective.

*Proof.* Since f is both surjective and injective, f is bijective.
#+end_quote

* Problem 4 [DONE] [CHECKED]
** Task
Consider all functions from {A,B,C,D,E,F,G} to {1,2,3,4,5,6,7}. How many different functions are there? How many of these functions are injective? How many are there surjective? How many are bijective?

** Notes
Domain: {A,B,C,D,E,F,G}
Codomain: {1,2,3,4,5,6,7}

The question is in how many ways can I link elements of domain with elements of codomain.

*Bijective*
First of all, there are 7! bijective functions.
With each domain element being related to one codomain element.

*Surjective*
Since each element of codomain must be related to the element of domain, and since there are the same number of elements in both, and since no element of domain can be related to the multiple of elements of codomain, there are 7! surjection functions

*Injective*
Since each element of codomain must has maximum of one relation to domain. Thus, there are 7! * 7 injection functions.

** Solution
- *Definitions.*
  - A function :: assigns to each domain element exactly one element of codomain.
  - Injective :: no two distinct domain elements map to the same codomain element.
  - Surjective :: every codomain element is hit by at least one domain element.
  - Bijective :: both injective and surjective.

- *Total functions.*
  Each of the domain elements can be assigned to any of the 7 codomain elements. So the number of functions is 7^7.

  Total functions {A,B,C,D,E,F,G} -> {1,2,3,4,5,6,7} = 7^7

- *Injective functions.*
  - each domain element must be assigned to one element of codomain
  - no multiple elements of domain point to the same element of codomain
  - number of elements in domain and codomain are equal

  Thus, each domain element is linked with unique element of codomain, resulting in a list of 7 pairs.
  Therefore, there are 7! ways to arrange the pairs.

- *Surjective functions.*
  - each domain element must be assigned to one element of codomain
  - every codomain element must be hit by at least one domain element
  - number of elements in domain and codomain are equal

  Thus, each domain element is linked with unique element of codomain, resulting in a list of 7 pairs.
  Therefore, there are 7! ways to arrange the pairs.

- *Bijective functions.*
  - each domain element must be assigned to one element of codomain
  - every codomain element must be hit by at least one domain element
  - no multiple elements of domain point to the same element of codomain
  - number of elements in domain and codomain are equal

  Thus, each domain element is linked with unique element of codomain, resulting in a list of 7 pairs.
  Therefore, there are 7! ways to arrange the pairs.

* Problem 5 [DONE]
** Task
Prove that f : ℕ x ℕ -> ℕ defined as f(m,n) = 2^(m-1) * (2n - 1) is bijective.

** Notes
- Injective :: no multiple elements of domain being related to the same element of codomain.
- Surjective :: every element of codomain has relation with at least one element of domain.
- Bijective :: both injective and surjective.

#+begin_quote Surjection proof
*Proposition.* f : ℕ x ℕ -> ℕ, f(m,n) = 2^(m-1) * (2n - 1) is surjective.

*Proof.*

2^(m-1) can be either 1 or multiples of 2.

Let k = 2r + 1, r ∈ ℕ.
k = 2^(1-1) * (2n - 1)
k = 2(n - 1) + 1
replace 2(n-1) with 2r since both are even
k = 2r + 1
Thus, any odd ℕ can be represented as 2^(m-1) * (2n - 1); m,n ∈ ℕ.

Since, 2^(m-1) is power of 2, and (2n - 1) can represent any odd ℕ. Due to the Fundamental Theorem of Arithmetic,

"Every integer greater than 1 is either a prime number itself or can be uniquely expressed as a product of prime numbers, with the order of the factors not mattering."

Thus, every ℕ number can be represented in the form of 2^(m-1) * (2n - 1). Therefore, f is surjective.
#+end_quote

#+begin_quote Injection proof
*Proposition.* f : ℕ x ℕ -> ℕ, f(m,n) = 2^(m-1) * (2n - 1) is injective.

*Proof.* Assume f(m,n) = f(m',n'). Write a = m - 1, a' = m' - 1. Then,

2^(m-1) * (2n - 1) = 2^(m'-1) * (2n' - 1)
2^a * (2n - 1) = 2^a' * (2n' - 1)

WLOG suppose a <= a', dividing by 2^a gives:
(2n - 1) = 2^(a'-a) * (2n' - 1)

LFS is odd. If a'-a > 0, RHS would be even. Meaning that a = a', thus, m = m'.

2^(m-1) * (2n - 1) = 2^(m-1) * (2n' - 1)       (divide both sides by 2^(m-1))
          (2n - 1) = (2n' - 1)                 (add 1 and divide by 2 both sides)
                 n = n'

Thus, since f(m,n) = f(m',n') implies (m,n) = (m',n'), f is injective.
#+end_quote

** Solution
#+begin_quote Surjection proof
*Proposition.* f : ℕ x ℕ -> ℕ, f(m,n) = 2^(m-1) * (2n - 1) is surjective.

*Proof.* Let k ∈ ℕ. By unique factorisation, write k = 2^r * s, where r >= 0, and s is odd. Put

        m = r + 1, n = (s + 1)/ 2.

Since s is odd, n ∈ ℕ. Then,

f(m,n) = 2^(m-1) * (2n - 1)
       = 2^r * (2 * (s+1)/2 - 1)
       = 2^r * s
       = k.

Thus, every k ∈ ℕ has a preimage (m,n), so f is surjective.
#+end_quote

#+begin_quote Injection proof
*Proposition.* f : ℕ x ℕ -> ℕ, f(m,n) = 2^(m-1) * (2n - 1) is injective.

*Proof.* Assume f(m,n) = f(m',n'). Write a = m - 1, a' = m' - 1. Then,

2^(m-1) * (2n - 1) = 2^(m'-1) * (2n' - 1)
2^a * (2n - 1) = 2^a' * (2n' - 1)

WLOG suppose a <= a', dividing by 2^a gives:
(2n - 1) = 2^(a'-a) * (2n' - 1)

LFS is odd. If a'-a > 0, RHS would be even. Meaning that a = a', thus, m = m'.

2^(m-1) * (2n - 1) = 2^(m-1) * (2n' - 1)       (divide both sides by 2^(m-1))
          (2n - 1) = (2n' - 1)                 (add 1 and divide by 2 both sides)
                 n = n'

Thus, since f(m,n) = f(m',n') implies (m,n) = (m',n'), f is injective.
#+end_quote

#+begin_quote
*Proposition.* f : ℕ x ℕ -> ℕ, f(m,n) = 2^(m-1) * (2n - 1) is bijective.

*Proof.* Since f is both surjective and injective, f is bijective.
#+end_quote

* Problem 6 [DONE]
** Task
Given a list of numbers 1, ..., n, we want to find all possible permutations such that none of the numbers occupies its original place. Lets call them /interesting/. For example, for n = 3, we have thow interesting permutations: 312 and 231.

1. Find the number of interesting permutations for n = 4,5,6,7,8.
2. Study how the ratio of the total number of permutations to the number of interesting permutations behaves.

** Notes
Isn't it just a Ceasar encription algorithm, in which we just increment each of the letters indexes?

Thus, n = 3 would be:
123
312
231
123

or maybe I can use the permutations package to generate all permutations and then use some statement function to compare index values with the values with index of index.

** Solution
#+begin_src julia :results output
import Pkg;
Pkg.add("Combinatorics")
#+end_src

#+begin_src julia :results output
using Combinatorics

check_index(arr) = all(i -> arr[i] != i, 1:length(arr))

find_numbers(n) = begin
    counter = 0
    for perm in permutations(1:n)
        if check_index(perm)
            counter += 1
#             println(perm)
        end
    end
    return counter
end

for n in 3:8
    println("n = $n, derangements = ", find_numbers(n))
end
#+end_src

#+RESULTS:
: check_index (generic function with 1 method)
: find_numbers (generic function with 1 method)
: n = 3, derangements = 2
: n = 4, derangements = 9
: n = 5, derangements = 44
: n = 6, derangements = 265
: n = 7, derangements = 1854
: n = 8, derangements = 14833

* Problem 7 [DONE]
** Task
How many numbers between 1111111 and 9999999 are divisible by 3 or 5 but not 11?

** Notes
Its way to easy. Maybe I can work on optimisation. Like skipping if number ends by 2,4,6,8.

** Solution
- Solution 1
  #+begin_src julia :results output
  function count_numbers()
      function statement(n::Int)
          if (n % 3 == 0) && (n % 5 == 0) && (n % 11 != 0)
              return true
          end
          return false
      end

      counter = 0
      i = 1111111
      while i <= 9999999
          if statement(i)
              counter += 1
          end
          i += 1
      end

      println("number of found numbers: ", counter)
  end

  count_numbers()
  #+end_src

  #+RESULTS:
  : count_numbers (generic function with 1 method)
  : number of found numbers:538720

- Solution 2
  #+begin_src julia :results output
  println("number of found numbers: ", count(n -> (n % 3 == 0) && (n % 5 == 0) && (n % 11 != 0), 1111111:9999999))
  #+end_src

  #+RESULTS:
  : Number of found numbers: 538720

* Problem 8 [DONE]
** Task
Let us call a natural number charismatic if the sum of its digits is a perfect square. Find the sum of all charismatic numbers between 111111 and 999999.

** Notes
** Solution
- Solution 1
  #+begin_src julia :results output
  find_sum() = begin
      statement(n) = begin
          sum_of_digits = sum(map(x -> parse(Int, x), collect(string(n))))
          sqrt_sum = sqrt(sum_of_digits)
          return sqrt_sum == floor(sqrt_sum)
      end

      i = 111111
      sum_char = 0
      while i <= 999999
          if statement(i)
              sum_char += i
          end
          i += 1
      end

      println("sum of all charismatic numbers: ", sum_char)
  end

  find_sum()
  #+end_src

  #+RESULTS:
  : find_sum (generic function with 1 method)
  : sum of all charismatic numbers: 47061011005

- Solution 2
  #+begin_src julia :results output
  is_charismatic(n) = begin
      s = sum(parse.(Int, collect(string(n))))
      sqrt(s) == floor(sqrt(s))
  end

  find_sum() = begin
      total = sum(i for i in 111111:999999 if is_charismatic(i))
      println("sum of all charismatic numbers: ", total)
  end

  find_sum()
  #+end_src

  #+RESULTS:
  : is_charismatic (generic function with 1 method)
  : find_sum (generic function with 1 method)
  : sum of all charismatic numbers: 47061011005
