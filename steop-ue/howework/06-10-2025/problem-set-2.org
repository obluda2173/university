#+title: Problem Set 2
#+author: Erik An
#+email: obluda2173@gmail.com
#+date: <2025-10-06>
#+lastmod: <2025-10-10 08:36>
#+options: num:t
#+startup: overview

* Answers
** Problem 1
*** (A \ B) \ C = (A \ C) \ (B \ C)
- x ∈ (A \ B) \ C
  <=> (x ∈ A) ∧ (x ∉ B) ∧ (x ∉ C)

- x ∈ (A \ B) \ (B \ C)
  <=> (x ∈ A) ∧ (x ∉ C) ∧ (x ∉ (B \ C))

  - x ∉ (B \ C)
    <=> ¬(x ∈ B ∧ x ∉ C)
    <=> x ∉ B v x ∈ C

    since x ∉ C, x ∉ B

  therefore
  x ∈ (A \ B) \ (B \ C)  <=>  (x ∈ A) ∧ (x ∉ B) ∧ (x ∉ C)

*** ∩(x ∈ R)[3 - x^2, 5 + x^2] = [3, 5]
- ∩(x ∈ R)[3 - x^2, 5 + x^2] = [3, 5]

  this means that [3, 5] ⊆ ∩(x ∈ R)[3 - x^2, 5 + x^2]

  take y ∈ [3, 5]

  ∀ x ∈ R, x^2 >= 0

  thus

  3 - x^2 <= 3 <= y <= 5 <= 5 + x^2

  thus

  ∀ x ∈ R, y ∈ [3 - x^2, 5 + x^2],

** Problem 2
*** (P ∨ ¬Q) => (P ∧ Q)
|-----+-----+------+------------+-----------+-----------------------|
| *P* | *Q* | *¬Q* | *(P ∨ ¬Q)* | *(P ∧ Q)* | *(P ∨ ¬Q) => (P ∧ Q)* |
|-----+-----+------+------------+-----------+-----------------------|
| T   | T   | F    | T          | T         | T                     |
| T   | F   | T    | T          | F         | F                     |
| F   | T   | F    | F          | F         | T                     |
| F   | F   | T    | T          | F         | F                     |
|-----+-----+------+------------+-----------+-----------------------|
*** (P => Q) => (Q => P)
|-----+-----+------------+------------+------------------------|
| *P* | *Q* | *(P => Q)* | *(Q => P)* | *(P => Q) => (Q => P)* |
|-----+-----+------------+------------+------------------------|
| T   | T   | T          | T          | T                      |
| T   | F   | F          | T          | T                      |
| F   | T   | T          | F          | F                      |
| F   | F   | T          | T          | T                      |
|-----+-----+------------+------------+------------------------|

** Problem 3
*** Task
For each of these sentences, determine whether an inclusive “or”, or an exclusive “or”, is
intended.
1. Experience with C++ or Java is required.
2. Lunch includes soup or salad.
3. Publish or perish.
4. To enter the country you need a passport or a permanent residence permit.

*** Solution
1. *Inclusive*, since the ability to work with two languages would logically be more prefered.
2. *Exclusive*, since the lunch would most like offer either soup or salad.
3. *Exclusive*, since perish is not prefered after publishing and publishing is impossible after perishing.
4. *Inclusive*, since its just logical.

** Problem 4
*** Task
Let P,Q, and R be the propositions
• P: You have the flu.
• Q: You miss the final examination.
• R: You pass the course.

Express each of these propositions as an English sentence.
1. P => Q
2. ¬Q <=> R
3. Q => ¬R
4. (P => ¬R) ∨ (Q => ¬R)

*** Solution
1. "If =you have a flu=, then =you miss the final exam=."
2. "=You not miss the final examination= if and only if =you pass the course=."
   or
   "=You pass the course= if and only if =you not miss the final examination=."
3. "If =you miss the final examination=, then =you not pass the course=."
4. "If =you have a flu= or =you miss the final examination=, then =you not pass the course=."

** Problem 5
*** Task
Five friends have access to a chat room. Is it possible to determine who is chatting if the following information is known?

- Either Kevin or Heather, or both, are chatting.
- Either Randy or Vijay, but not both, are chatting.
- If Abby is chatting, so is Randy.
- Vijay and Kevin are either both chatting or neither is.
- If Heather is chatting, then so are Abby and Kevin.

Explain your reasoning.

*** Solution
- Names: Kevin, Heather, Randy, Vijay, Abbey

#+begin_src julia :session none :results value
# s - statement
s1(K,H) = K || H
s2(R,V) = xor(R,V)
s3(A,R) = !A || R
s4(K,V) = K == V
s5(H,A,K) = !H || (A && K)

function validation(chat_list::Vector{Bool})
    K = chat_list[1]
    H = chat_list[2]
    R = chat_list[3]
    V = chat_list[4]
    A = chat_list[5]

    if s1(K, H) && s2(R, V) && s3(A, R) && s4(K, V) && s5(H, A, K)
        return true
    end

    return false
end

function get_chats()
    n = 5
    result = Vector{Vector{Bool}}()

    for mask in 0:(1 << n) - 1
        combination = Vector{Bool}()

        for j in 1:n
            if ((mask >> (j - 1)) & 1) == 1
                push!(combination, true)
            else
                push!(combination, false)
            end
        end
        if validation(combination)
            push!(result, combination)
        end
    end
    return result
end

get_chats()

#+end_src

#+RESULTS:
: Bool[1, 0, 0, 1, 0]

** Problem 6
*** Task
A proposition that is always true is called a tautology. Prove (without using a truth table) that (P ∧ Q) => (P ∨ Q) is a tautology.

*** Solution
- A => B = ¬A v B (Material Implication)

(P ∧ Q) => (P ∨ Q) = ¬(P ∧ Q) v (P v Q)
= ¬P v ¬Q v P v Q
= (¬P v P) v (¬Q v Q)
= T v T
= T

** Problem 7
*** Task
Express each of these statements using quantifiers. Then form the negation of the statement
and simplify it. Next, express the negation in simple English.

1. All dogs have fleas.
2. There is a horse that can add.
3. Every koala can climb.
4. No monkey can speak French.
5. There exists a pig that can swim and catch fish.

*** Solution
**** ∀x(Dogs(x) => Fleas(x))
- Negation: ¬(∀ x (Dogs(x) => Fleas(x)))
  ¬(∀ x (Dogs(x) => Fleas(x)))
  <=> ∃x¬(Dogs(x) => Fleas(x)))
  <=> ∃x(Dogs(x) ∧ ¬Fleas(x)))
- English: There exists a Dog that does not have Fleas.

**** ∃x(Horse(x) ∧ Add(x))
- Negation: ¬(∃x(Horse(x) ∧ Add(x)))
  ¬(∃x(Horse(x) ∧ Add(x)))
  <=> ∀x¬(Horse(x) ∧ Add(x)))
  <=> ∀x(Horse(x) => ¬Add(x)))
- English: Every horses can not add.

**** ∀x(Coala(x) => Climb(x))
- Negation: ¬(∀x(Coala(x) => Climb(x)))
  ¬(∀x(Coala(x) => Climb(x)))
  <=> ∃x¬(Coala(x) => Climb(x))
  <=> ∃x(Coala(x) ∧ ¬Climb(x))
- English: There exists Coala that can not climb.

**** ∀x(Monkey(x) => ¬SpeakFrench(x))
- Negation: ¬(∀x(Monkey(x) => ¬SpeakFrench(x)))
  ¬(∀x(Monkey(x) => ¬SpeakFrench(x)))
  <=> ∃x¬(Monkey(x) => ¬SpeakFrench(x))
  <=> ∃x(Monkey(x) ∧ SpeakFrench(x))
- English: There exists a Monkey that can speak French.

**** ∃x(Pig(x) ∧ Swim(x) ∧ CatchFish(x))
- Negation: ¬(∃x(Pig(x) ∧ Swim(x) ∧ CatchFish(x)))
  ¬(∃x(Pig(x) ∧ Swim(x) ∧ CatchFish(x)))
  <=> ∀x¬(Pig(x) ∧ Swim(x) ∧ CatchFish(x))
  <=> ∀x(Pig(x) => ¬(Swim(x) ∧ CatchFish(x)))
  <=> ∀x(Pig(x) => (¬Swim(x) v ¬CatchFish(x)))
- English: No Pig both swims and catches fish.

** Problem 8
*** Task
1. Show that ∀x P(x) ∨ ∀x Q(x) and ∀x (P(x) ∨ Q(x)) are not logically equivalent.
2. Show that ∃x P(x) ∨ ∃x Q(x) and ∃x (P(x) ∨ Q(x)) are logically equivalent.

*** Solution
**** 1.
***** Let the domain be D = {a, b}
- P(a) = true, P(b) = false
- Q(a) = false, Q(b) = true

Check:
- For a: P(a) ∨ Q(a) = true
- For b: P(b) ∨ Q(b) = true
Thus, P(x) ∨ Q(x) is true in this model

But, for ∀xP(x) is false because P(b) is false, and ∀xQ(x) is false since P(a) is false.
Hence, ∀x P(x) ∨ ∀x Q(x) is false.

***** ∃x ϕ(x) ≡ ¬∀x ¬ϕ

- ∀x (P(x) ∨ Q(x)) = ¬∃x ¬(P(x) ∨ Q(x))
                   = ¬∃x (¬P(x) ∧ ¬Q(x))

- ∀x P(x) ∨ ∀x Q(x) = ¬∃x ¬p(x) v ¬∃x ¬q(x)
                    = ¬(∃x ¬p(x) ∧ ∃x ¬q(x))

- ∀x(P ∨ Q) ≡ ¬∃x(¬P ∧ ¬Q),
- ∀xP ∨ ∀xQ ≡ ¬(∃x¬P ∧ ∃x¬Q).

**** 2.
∃x P(x) ∨ ∃x Q(x) and ∃x (P(x) ∨ Q(x))

∃x(P(x) ∨ Q(x)) = ¬∀x ¬(P(x) ∨ Q(x))
                = ¬∀x (¬P(x) ∧ ¬Q(x))
                = ¬(∀x¬P(x) ∧ ∀x¬Q(x))
                = ¬∀x¬P(x) v ¬∀x¬Q(x)
                = ∃xP(x) ∨ ∃xQ(x)

** Problem 9
*** Task
Construct a truth table for the proposition P ∨ Q ∧ (P => R) => (P => ((Q ∧ P) ∨ R)). You don’t need to do it manually and can use Julia library TruthTables1.

*** Solution
#+begin_src julia :session none :results output
using TruthTables
@truthtable P || Q && (P --> R) --> (P --> ((Q && P) || R))
#+end_src

#+RESULTS:
#+begin_example
TruthTable
┌───────┬───────┬───────┬─────────────────────────────────────────┐
│   P   │   Q   │   R   │ P ∨ Q ∧ (P --> R) --> (P --> Q ∧ P ∨ R) │
├───────┼───────┼───────┼─────────────────────────────────────────┤
│ true  │ true  │ true  │ true                                    │
│ true  │ true  │ false │ true                                    │
│ true  │ false │ true  │ true                                    │
│ true  │ false │ false │ false                                   │
│ false │ true  │ true  │ true                                    │
│ false │ true  │ false │ true                                    │
│ false │ false │ true  │ true                                    │
│ false │ false │ false │ true                                    │
└───────┴───────┴───────┴─────────────────────────────────────────┘
#+end_example
